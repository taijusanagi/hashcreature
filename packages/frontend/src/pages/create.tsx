import React from "react";
import { ethers } from "ethers";
import {
  getEthersSigner,
  ChainIdType,
  getNetworkConfig,
  getContract,
} from "../modules/web3";

import "./create.css";

export const Create: React.FC = () => {
  const [
    waitingTransactionConfirmation,
    setWaitingTransactionConfirmation,
  ] = React.useState(false);

  const [slippage, setSlippage] = React.useState("0");
  const [priceToMint, setPriceToMint] = React.useState("");
  const [priceToBurn, setPriceToBurn] = React.useState("");
  const [dialogHeader, setDialogHeader] = React.useState("");
  const [dialogText, setDialogText] = React.useState("");
  const [tokenId, setTokenId] = React.useState("");

  React.useEffect(() => {
    const chainId = "4";
    const network = getNetworkConfig(chainId);
    const contract = getContract(network.contractAddress, chainId);
    contract.totalSupply().then((supply: any) => {
      contract
        .getPriceToMint(supply)
        .then((price: any) => setPriceToMint(price.toString()));
      contract
        .getPriceToBurn(supply)
        .then((price: any) => setPriceToBurn(price.toString()));
    });
  }, []);

  const handleSlippage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setSlippage(event.target.value);
  };

  interface Dialog {
    header: string;
    text: string;
  }

  const openDialog = ({ header, text }: Dialog) => {
    const dialog = document.getElementById("dialog") as any;
    setDialogHeader(header);
    setDialogText(text);
    dialog.showModal();
  };

  const openPrompt = () => {
    const dialog = document.getElementById("prompt") as any;
    dialog.showModal();
  };

  const handleTokenIdChain = (event: React.ChangeEvent<HTMLInputElement>) => {
    setTokenId(event.target.value);
  };

  const mintNft = async () => {
    setWaitingTransactionConfirmation(true);
    const signer = await getEthersSigner();
    const chainId = await signer.getChainId();
    if (chainId != 4) {
      openDialog({
        header: "Wrong Network Detected!",
        text: "Please connect to Rinkeby Network",
      });
      return;
    }
    const value = ethers.BigNumber.from(priceToMint)
      .mul(parseInt(slippage) + 1)
      .toString();
    const { contractAddress } = getNetworkConfig(
      chainId.toString() as ChainIdType
    );
    const contract = getContract(contractAddress).connect(signer);

    await contract
      .mint({ value })
      .then(({ hash }: { hash: string }) => {
        openDialog({
          header: "Congratulation!",
          text: `You can check your asset in OpenSea soon. Tx:${hash}`,
        });
      })
      .catch((err: Error) => {
        console.error(Error);
        openDialog({
          header: "Transaction Failed!",
          text: `Please try again... I hope it will work...`,
        });
      });
  };

  const burnNFT = async () => {
    setWaitingTransactionConfirmation(true);
    const signer = await getEthersSigner();
    const chainId = await signer.getChainId();
    if (chainId != 4) {
      openDialog({
        header: "Wrong Network Detected!",
        text: "Please connect to Rinkeby Network",
      });
      return;
    }
    const { contractAddress } = getNetworkConfig(
      chainId.toString() as ChainIdType
    );
    const contract = getContract(contractAddress).connect(signer);

    await contract
      .burn(tokenId)
      .then(({ hash }: { hash: string }) => {
        openDialog({
          header: "Thank you for having time with us!",
          text: `Your HashCretures is burned at Tx:${hash}`,
        });
      })
      .catch((err: Error) => {
        console.error(err.message);
        openDialog({
          header: "Transaction Failed!",
          text: `Please try again... I hope it will work...`,
        });
      });
  };

  return (
    <div className="container">
      <div className="nes-container is-dark with-title is-centered">
        <p className="title">HashCreatures</p>
        <p>
          HashCreatures are generated by minting transaction hash. Svg and
          metadata is generated on chain. HashCreatures image will be
          deteriorated when transferred, and only 5 transfer is allowed. A
          bonding curve determins the mint price, and 90% of the mint price is
          stored in a reserve to refund burned HashCreatures.
        </p>
      </div>
      <div className="slippage">
        <h4>Slippage for Mint Creatures</h4>
        <div className="slippage_radio" onChange={handleSlippage}>
          <label>
            <input
              type="radio"
              className="nes-radio"
              name="slippage"
              defaultChecked
              value="0"
            />
            <span>0</span>
          </label>
          <label>
            <input
              type="radio"
              className="nes-radio"
              name="slippage"
              value="1"
            />
            <span>1</span>
          </label>
          <label>
            <input
              type="radio"
              className="nes-radio"
              name="slippage"
              value="2"
            />
            <span>2</span>
          </label>
          <label>
            <input
              type="radio"
              className="nes-radio"
              name="slippage"
              value="3"
            />
            <span>3</span>
          </label>
        </div>
      </div>
      <div className="mint_button">
        <button
          type="button"
          className={`${
            !priceToMint && "is-disabled"
          } nes-btn is-success mint_button`}
          onClick={mintNft}
          disabled={!priceToMint}
        >
          Mint for {priceToMint ? ethers.utils.formatEther(priceToMint) : "?"}{" "}
          ETH
        </button>
      </div>
      <div className="mint_button">
        <button
          type="button"
          className={`${
            !priceToBurn && "is-disabled"
          } nes-btn is-error mint_button`}
          onClick={openPrompt}
          disabled={!priceToMint}
        >
          Burn for {priceToBurn ? ethers.utils.formatEther(priceToBurn) : "?"}{" "}
          ETH
        </button>
      </div>
      <section>
        <dialog className="nes-dialog is-dark" id="dialog">
          <form method="dialog">
            <p className="title">{dialogHeader}</p>
            <p>{dialogText}</p>
            <menu className="dialog-menu">
              <button className="nes-btn is-primary">Confirm</button>
            </menu>
          </form>
        </dialog>
      </section>
      <section>
        <dialog className="nes-dialog is-dark" id="prompt">
          <form method="dialog">
            <p className="title">Please input your token ID to burn.</p>
            <div className="nes-field is-inline">
              <label htmlFor="dark_field">ID</label>
              <input
                type="number"
                id="dark_field"
                className="nes-input is-dark"
                placeholder="1"
                onChange={handleTokenIdChain}
              />
            </div>
            <menu className="dialog-menu">
              <div className="confirm_button ">
                <button
                  className={`${!tokenId && "is-disabled"} nes-btn is-primary`}
                  onClick={burnNFT}
                  disabled={!tokenId}
                >
                  Confirm
                </button>
              </div>
            </menu>
          </form>
        </dialog>
      </section>
    </div>
  );
};

export default Create;
